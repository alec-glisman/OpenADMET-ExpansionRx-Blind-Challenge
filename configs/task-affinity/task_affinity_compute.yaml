# Task Affinity Computation Only Configuration
# =============================================
# Configuration for computing task affinity matrix without full training.
# Used for analysis and visualization of task relationships.
#
# Usage:
#   python -m admet.cli.compute_task_affinity \
#     --config configs/task-affinity/task_affinity_compute.yaml \
#     --save-path results/task_affinity.npz \
#     --plot-heatmap results/affinity_heatmap.png

# Data configuration
data:
  # Training data file
  train_file: "assets/dataset/split_train_val/v3/quality_high/bitbirch/multilabel_stratified_kfold/data/split_0/fold_0/train.csv"

  smiles_col: "SMILES"
  target_cols:
    - "LogD"
    - "Log KSOL"
    - "Log HLM CLint"
    - "Log MLM CLint"
    - "Log Caco-2 Permeability Papp A>B"
    - "Log Caco-2 Permeability Efflux"
    - "Log MPPB"
    - "Log MBPB"
    - "Log MGMB"

# Task Affinity Computation Settings (Legacy Pre-Training Approach)
# ------------------------------------------------------------------
# DEPRECATED: This uses gradient cosine similarity. For paper-accurate
# implementation, use inter_task_affinity below instead.
task_affinity:
  # Affinity computation
  affinity_epochs: 2 # More epochs for stable estimates
  affinity_batch_size: 64
  affinity_lr: 0.001

  # Affinity scoring
  affinity_type: "cosine"
  normalize_gradients: true

  # Clustering (for automatic grouping)
  n_groups: 3
  clustering_method: "agglomerative"

  # System settings
  device: "auto"
  seed: 42
  log_affinity_matrix: true

# =============================================================================
# Inter-Task Affinity Configuration (Paper-Accurate Implementation)
# =============================================================================
# Computes inter-task affinity during training using the lookahead method from:
# "Efficiently Identifying Task Groupings for Multi-Task Learning"
# (Fifty et al., NeurIPS 2021, https://arxiv.org/abs/2109.04617)
#
# Formula: Z^t_{ij} = 1 - L_j(θ^{t+1}_{s|i}) / L_j(θ^t_s)
#
# For standalone affinity computation, you would typically:
# 1. Enable this during a short training run
# 2. Extract the final affinity matrix from MLflow artifacts
# =============================================================================
inter_task_affinity:
  # Enable/disable inter-task affinity computation
  enabled: true

  # Compute affinity at every step for accurate measurement
  compute_every_n_steps: 1

  # Log running average frequently for analysis
  log_every_n_steps: 50

  # Log epoch-level summary statistics
  log_epoch_summary: true

  # Log individual step matrices for detailed analysis
  log_step_matrices: true

  # Learning rate for lookahead computation
  lookahead_lr: 0.001

  # Use current optimizer learning rate for lookahead
  use_optimizer_lr: true

  # Patterns to exclude from shared parameters (task-specific layers)
  exclude_param_patterns:
    - predictor
    - ffn
    - output
    - head
    - readout

  # Log affinity metrics to MLflow
  log_to_mlflow: true

# Output settings
output:
  # Save paths (can override via CLI)
  affinity_matrix_path: "results/task_affinity_matrix.npz"
  affinity_csv_path: "results/task_affinity_matrix.csv"
  heatmap_path: "results/task_affinity_heatmap.png"
  groups_json_path: "results/task_groups.json"

  # Heatmap settings
  heatmap_figsize: [10, 8]
  heatmap_cmap: "RdBu_r"
  heatmap_dpi: 150
